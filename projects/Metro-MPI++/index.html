<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Metro-MPI++: Accelerating Verilog/System Verilog Simulations | Kislay Arya </title> <meta name="author" content="Kislay Arya"> <meta name="description" content="A GSoC project to automatically partition and parallelize hardware simulations in Verilator using MPI."> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://kislay536.github.io/projects/Metro-MPI++/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Kislay</span> Arya </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">About </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item active"> <a class="nav-link" href="/projects/">projects <span class="sr-only">(current)</span> </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching </a> </li> <li class="nav-item "> <a class="nav-link" href="/people/">people </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/books/">bookshelf</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Metro-MPI++: Accelerating Verilog/System Verilog Simulations</h1> <p class="post-description">A GSoC project to automatically partition and parallelize hardware simulations in Verilator using MPI.</p> </header> <article> <div class="row"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/mmpi-logo-480.webp 480w,/assets/img/mmpi-logo-800.webp 800w,/assets/img/mmpi-logo-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/mmpi-logo.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" title="Metro-MPI++" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <h1 id="project-description">Project Description</h1> <p>As modern SoC designs especially manycore-based ones get more and more complex, simulation performance becomes a serious bottleneck. RTL simulation is still the most accurate way to verify digital designs, but the traditional monolithic simulators don’t scale well when the design has a lot of replicated blocks like cores or NoC components. This often results in extremely long simulation times, which slows down development.</p> <p>Newer simulators do give us the option to do parallel simulation but they lack at one important aspect and that is they fail to give the Simulator(or the compiler that doees the parsing and AST construction) a perspective of the physical structure of the hardware design. Becasue of this, the preprocessing, AST Construction, elaboration and optimization follows a standard approach that a general purpose software language compiler like GCC follows. But unlike C and C++, HDLs carry much more information that are kind-of not visible to the GP compilers. An intuitive example would be the case of gem5, when we are modifying some structurs in gem5 let’s say the O3 CPU model than it may happen that we are able to complete the building process of the binary of any architecture i.e. it doesn’t throw any errors but despite this it may happen that it fails terribily during the run simulations. ANd this happens because of the same reason, that g++ doesn’t know what this code represents and it does exactly the same thing it does with other c++ codes. Apart from this, the current parallel simulation frameworks lacks the ability to scale.</p> <p>To handle scaling issue, my mentors, Dr. Guillem and Prof. Jonathan have came up with a nice way of parallelizing RTL simulation of OpenPiton, <a href="https://ieeexplore.ieee.org/abstract/document/10137080" rel="external nofollow noopener" target="_blank">Metro-MPI</a>, by manually generating different binaries that can be simulated parallely on different threads across multiple nodes by exploiting the hardware boundaries like the NoC structures and by using Message Passing Interface.</p> <p>In this project, Metro-MPI++, my goal was to take the same philosophy as in Metro-MPI and enable verilator, an open source system verilog simulator,-</p> <ul> <li>To automatically detect the possible partitions that can be simulated parallely.</li> <li>To extract as much information as possible about the connecting interface of these partitions to enable Verilator to take informed descisions.</li> <li>Generate intermediate files and structures needed to insert MPI to do parallel simulations.</li> </ul> <h2 id="metro-mpi-workflow">Metro-MPI++ Workflow</h2> <p>I will be describing the entire plan here</p> <h2 id="prerequisite-migrating-metro-mpi-to-verilator-v5x">Prerequisite: Migrating Metro MPI to Verilator v5.x</h2> <p>Before implementing the main partitioning and MPI integration features, the first critical step was to make Metro-MPI(which is implemented on top of OpenPiton, world’s first open source, general purpose, multithreaded manycore processor with 64-bit Ariane RISC-V core) work with the latest Verilator v5.x versions. The original framework relied on Verilator v4.x, but with newer versions like v5.038 available, upgrading was essential for long-term maintainability and compatibility.</p> <p>This upgrade introduced several challenges due to major internal changes in Verilator between v4.x and v5.x:</p> <ul> <li> <p>Common Issues in All Versions of Verilator v5.x :</p> <ul> <li> <strong>Precompiled Headers (pch)</strong>: v5.x uses precompiled headers, whereas v4.x doesn’t. So, during the build, in order to prevent calling the pch files, I modified the <code class="language-plaintext highlighter-rouge">verilator/include/verilated.mk</code> (added the <code class="language-plaintext highlighter-rouge">-c</code> flag) to just compile. Later during the build, when pch is being called, it will already be compiled.</li> <li> <strong>Missing Headers</strong>: There were a few functions that were undeclared and were used in my metro chipset.cpp, like init jbus model call. The most probable reason could be that v4.x is very permissive and would let a file refer to a function declared somewhere else even if the header was missing, whereas v5.x is not. It got fixed by just declaring the functions in the file from which they were being called.</li> <li> <p><strong>v5.x Initialization Sequence</strong>: v4.x was consistent with SystemVerilog, i.e., initial blocks would run before the DPI calls into the simulation, but in v5.x, the scheduler was rewritten. DPI-C calls from the host side can be scheduled before the initial blocks in the design have executed. This means <code class="language-plaintext highlighter-rouge">b_open()</code> or similar setup code in an initial block might not have run yet when <code class="language-plaintext highlighter-rouge">write_64b_call()</code> or <code class="language-plaintext highlighter-rouge">read_64b_call()</code> is first called. It may try to access a memory address even before it is initialized, resulting in a segmentation fault.</p> <div class="language-cpp highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="cm">/* ----------------------------------------------------------------
* Guard against the new Verilator 5.x scheduler: the first call may
* arrive before any initial block that used to call b_open().
* ---------------------------------------------------------------- */</span>
<span class="k">if</span> <span class="p">(</span><span class="n">sysMem</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// sysMem = b_create(); // returns a valid (but empty) root</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"[IOB] Lazy init_jbus_model_call at t=%llu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span>
<span class="n">Verilated</span><span class="o">::</span><span class="n">time</span><span class="p">());</span>
<span class="n">init_jbus_model_call</span><span class="p">((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="s">"mem.image"</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div> </div> <p>By doing this inside the <code class="language-plaintext highlighter-rouge">write_64b_call()</code> or <code class="language-plaintext highlighter-rouge">read_64b_call()</code> functions, we are initializing the root/memory if it is not initialized, with a 0 value.</p> </li> </ul> </li> <li> <p>Issues with Particular Versions:</p> <p><strong>Negative Values</strong>: The issue of this error is most probably the fact that v5.x is more strict and has more standards-compliant error checking. In the design, any signal must not get any negative value at all, and if it may happen, then it’s better to have padding to clip it to 0.</p> <div class="language-verilog highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1">// The value in the condition may be negative</span>
<span class="n">return_data_S2</span> <span class="o">=</span> <span class="p">,</span>
                 <span class="n">state_data_trans_S2</span><span class="p">[</span><span class="err">‘</span><span class="n">L2_STATE_DATA</span><span class="p">]</span><span class="o">}</span><span class="p">;</span>
</code></pre></div> </div> <div class="language-verilog highlighter-rouge"> <div class="highlight"><pre class="highlight"><code><span class="c1">// Better way to implement the same logic</span>
<span class="k">localparam</span> <span class="n">PAD_BITS</span> <span class="o">=</span> <span class="err">‘</span><span class="n">L2_STATE_DATA_WIDTH</span> <span class="o">&gt;=</span> <span class="err">‘</span><span class="n">L2_P1_DATA_BUF_IN_WIDTH</span>
                      <span class="o">?</span> <span class="mi">0</span>
                      <span class="o">:</span> <span class="err">‘</span><span class="n">L2_P1_DATA_BUF_IN_WIDTH</span> <span class="o">-</span> <span class="err">‘</span><span class="n">L2_STATE_DATA_WIDTH</span><span class="p">;</span>
<span class="n">return_data_S2</span> <span class="o">=</span> <span class="p">,</span> <span class="n">state_data_trans_S2</span><span class="p">[</span><span class="err">‘</span><span class="n">L2_STATE_DATA</span><span class="p">]</span><span class="o">}</span><span class="p">;</span>
</code></pre></div> </div> </li> </ul> <h2 id="automatic-partitioning-and-connectivity-analysis">Automatic Partitioning and Connectivity Analysis</h2> <p>The core of the Metro-MPI tool is its ability to automatically analyze a Verilog design to identify parallelizable sections and map their communication pathways. This process is handled by the <code class="language-plaintext highlighter-rouge">PartitionPortAnalyzer</code> and <code class="language-plaintext highlighter-rouge">HierCellsGraphVisitor</code> classes.</p> <h3 id="automatic-partition-detection">Automatic Partition Detection</h3> <p>The tool does not require users to manually specify which modules to partition. It performs automatic detection by first building a complete hierarchical graph of the design using the <code class="language-plaintext highlighter-rouge">HierCellsGraphVisitor</code> class. It then traverses this graph and computes a Blake hash for each module’s structural hierarchy. By searching for identical hashes, the tool can automatically and efficiently identify structurally identical, repeated module instances that are prime candidates for parallel simulation.</p> <h3 id="detailed-connectivity-analysis">Detailed Connectivity Analysis</h3> <p>Once partition instances are identified, the <code class="language-plaintext highlighter-rouge">PartitionPortAnalyzer</code> class conducts a deep analysis of the parent module’s netlist to understand the data flow.</p> <ul> <li>It traces signals through chained <code class="language-plaintext highlighter-rouge">assign</code> statements using the <code class="language-plaintext highlighter-rouge">resolveWireChain</code> function to find the ultimate source wire for any given port connection.</li> <li>It applies a sophisticated filtering logic that intelligently prioritizes true <code class="language-plaintext highlighter-rouge">Output</code> ports as data originators over passive, passthrough <code class="language-plaintext highlighter-rouge">assign</code> statements, resulting in a cleaner data-flow graph.</li> <li>The analyzer is capable of finding the direction of ports on any instantiated module within the parent scope, whether it is a designated partition or not, by maintaining a map of instance names to their AST definitions (<code class="language-plaintext highlighter-rouge">m_instanceToModulePtr</code>).</li> </ul> <h3 id="global-uniqueness-and-reporting">Global Uniqueness and Reporting</h3> <p>To ensure the generated code is robust, the analyzer performs several finalization steps.</p> <ul> <li>It conducts a global, link-aware name disambiguation phase at the end of the analysis. This process groups all signals by their communication link (e.g., all signals from rank 1 to rank 0) and renames any duplicate remote port names within that group to guarantee uniqueness.</li> <li>The final, fully analyzed connectivity graph is serialized into a <code class="language-plaintext highlighter-rouge">partition_report.json</code> file. This JSON file acts as the central, authoritative source of information for all subsequent code generation stages.</li> </ul> <h2 id="verilog-rewriting-for-mpi-integration">Verilog Rewriting for MPI Integration</h2> <p>The tool automatically modifies the user’s Verilog design to intercept signals for MPI communication, creating a new, parallel-ready version of the design without altering the original source files. This is orchestrated by the <code class="language-plaintext highlighter-rouge">MPIFileGenerator</code> class.</p> <h3 id="dpi-stub-generation">DPI Stub Generation</h3> <p>For the module that has been chosen for partitioning, a generic “stub” module is generated. This stub module shares the exact same port list as the original module, but its internal logic is completely replaced by an <code class="language-plaintext highlighter-rouge">always @(*)</code> block containing a DPI (Direct Programming Interface) call to an external C++ function. This DPI call serves as the fundamental bridge between the Verilog simulation domain and the C++ MPI backend.</p> <h3 id="instance-specific-wrappers">Instance-Specific Wrappers</h3> <p>For each individual instance of the partitioned module (e.g., <code class="language-plaintext highlighter-rouge">tile0</code>, <code class="language-plaintext highlighter-rouge">tile1</code>), a unique Verilog wrapper module is created. Each wrapper instantiates the generic DPI stub and passes that instance’s unique, pre-assigned MPI rank as a Verilog parameter (<code class="language-plaintext highlighter-rouge">PARTITION_ID</code>). This allows the C++ backend to identify which specific partition instance is making a DPI call.</p> <h3 id="parent-module-modification">Parent Module Modification</h3> <p>The final step in the Verilog modification is to rewrite the parent module that instantiates the partitions. The tool reads the original parent module’s source file and uses a regular expression (<code class="language-plaintext highlighter-rouge">std::regex</code>) to find and replace every instantiation of the original partitioned module with its corresponding new, instance-specific wrapper. This effectively re-wires the top-level design to use the MPI-enabled stubs.</p> <h2 id="c-simulation-and-harness-code-generation">C++ Simulation and Harness Code Generation</h2> <p>A significant feature of the tool is the automated generation of all C++ code required to manage and execute the distributed MPI simulation.</p> <h3 id="mpi-communication-layer">MPI Communication Layer</h3> <p>The <code class="language-plaintext highlighter-rouge">MPICodeGenerator</code> class is responsible for creating a low-level MPI communication layer from the <code class="language-plaintext highlighter-rouge">partition_report.json</code> file. It generates a file named <code class="language-plaintext highlighter-rouge">metro_mpi.cpp</code> which contains:</p> <ul> <li>Custom C++ <code class="language-plaintext highlighter-rouge">structs</code> tailored for each communication link (e.g., <code class="language-plaintext highlighter-rouge">struct mpi_rank_1_to_2_t</code>), ensuring type safety.</li> <li>Custom <code class="language-plaintext highlighter-rouge">MPI_Datatype</code>s created using <code class="language-plaintext highlighter-rouge">MPI_Type_create_struct</code>, which is the most efficient method for transferring structured data in MPI.</li> <li>A clean API of wrapper functions (e.g., <code class="language-plaintext highlighter-rouge">mpi_send_rank_1_to_2(...)</code>) that abstract away the underlying MPI calls.</li> </ul> <h3 id="partition-simulation-executable">Partition Simulation Executable</h3> <p>The <code class="language-plaintext highlighter-rouge">MPIMainGenerator</code> class generates a complete, standalone C++ program (<code class="language-plaintext highlighter-rouge">&lt;partition&gt;_main.cpp</code>) that serves as the simulation driver for each non-zero MPI rank. This generated file:</p> <ul> <li>Initializes the MPI environment and the specific Verilated model for that partition (e.g., <code class="language-plaintext highlighter-rouge">Vtile</code>).</li> <li>Contains initialization functions to set constant-tied inputs for each specific partition instance.</li> <li>Implements the main simulation loop (<code class="language-plaintext highlighter-rouge">while (!sim_end)</code>), which coordinates the <code class="language-plaintext highlighter-rouge">send</code>, <code class="language-plaintext highlighter-rouge">receive</code>, and <code class="language-plaintext highlighter-rouge">top-&gt;eval()</code> cycle for its rank.</li> </ul> <h3 id="rank-0-testbench-harness">Rank 0 Testbench Harness</h3> <p>To integrate with the main system simulation, the <code class="language-plaintext highlighter-rouge">Rank0MainGenerator</code> class generates code for the master process (Rank 0).</p> <ul> <li>It creates a C++ header file, <code class="language-plaintext highlighter-rouge">rank0_harness.h</code>, which contains the implementation of the DPI function that was imported into the Verilog stubs.</li> <li>This DPI function uses a <code class="language-plaintext highlighter-rouge">switch</code> statement based on the <code class="language-plaintext highlighter-rouge">partition_id</code> to translate the DPI call into the appropriate MPI send and receive calls to communicate with the correct partition process.</li> <li>The tool also generates a <code class="language-plaintext highlighter-rouge">README_integration.txt</code> file that provides clear, step-by-step instructions for users on how to include the harness and modify their existing testbench to work with the MPI co-simulation.</li> </ul> <h2 id="build-system-generation">Build System Generation</h2> <p>The tool automates the final step of the workflow: compiling the generated code into a runnable simulation.</p> <h3 id="makefile-generation">Makefile Generation</h3> <p>The <code class="language-plaintext highlighter-rouge">MakefileGenerator</code> class is responsible for creating a <code class="language-plaintext highlighter-rouge">Makefile.&lt;partition&gt;</code> for building the partition’s simulation executable. This Makefile contains all the necessary rules for Verilating the partition’s source files and compiling the generated C++ code.</p> <h3 id="configuration-preservation">Configuration Preservation</h3> <p>The <code class="language-plaintext highlighter-rouge">MakefileGenerator</code> intelligently parses the original Verilator command line, which is passed to it as <code class="language-plaintext highlighter-rouge">argString</code>. It extracts relevant user-defined flags such as <code class="language-plaintext highlighter-rouge">-CFLAGS</code>, <code class="language-plaintext highlighter-rouge">-LDFLAGS</code>, <code class="language-plaintext highlighter-rouge">--trace</code>, and <code class="language-plaintext highlighter-rouge">-D</code> definitions, and includes them in the generated Makefile. This ensures that the user’s original build configuration and options are preserved in the parallel simulation build.</p> <h3 id="mpi-compiler-integration">MPI Compiler Integration</h3> <p>Crucially, the generated <code class="language-plaintext highlighter-rouge">Makefile</code> is configured to use an MPI C++ compiler wrapper (e.g., <code class="language-plaintext highlighter-rouge">mpic++</code>) for the compilation and linking stages. This guarantees that the final executable is correctly linked against the necessary MPI libraries, enabling it to participate in the distributed simulation.</p> </article> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Kislay Arya. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>